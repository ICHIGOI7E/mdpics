---
title: 函数与装饰器
abbrlink: 1989037369
date: 2022-03-12 21:17:54
tags: Python
---
## 函数
Python 是一门支持面向对象的编程语言，但除此之外，Python 对函数的支持也毫不逊色。函数在 Python 中是一等对象，这意味着我们可以把函数自身作为函数参数来使用。

### 函数参数的常用技巧
参数（Parameter）是函数的重要组成部分，它是函数最主要的输入源，决定了调用方使用函数时的体验。Python 函数的参数默认值只会在函数定义阶段被创建一次，别将可变类型作为参数默认值，使用 None 来替代：
```python
def append_value(value, items=[]):
    items.append(value)
    return items
```
```python
def append_value(value, items=None):
    # 在函数内部进行判断，保证参数默认每次都使用一个新的空列表
    if items is None:
        items = []
    items.append(value)
    return items
```

定义一个特殊对象（标记变量）作为参数默认值，严格区分调用方是不是**真的**提供了这个默认参数：
```python
# object 通常不会单独使用，但是拿来做这种标记变量刚刚好
_not_set = object()

def dump_value(value, extra=_not_set):
    if extra is _not_set:
        # TODO: 调用方没有传递 extra 参数
```
<!--more-->
> More than three (polyadic) requires very special justification \-\- and then shouldn't be used anyway.
\-\- Clean Code

Python 里的函数不光支持通过有序**位置参数**（Positional Argument）调用，还能指定参数名，通过**关键字参数**（Keyword Argument）的方式调用。当你要调用参数超过 3 个的函数时，使用关键字参数模式可以大大提高代码的可读性，通过在参数列表中插入 * 符号，该符号后的所有参数都变成了仅限关键字参数：
```python
def query_users(limit, offset, *, min_followers_count, include_profile):
    # TODO: 查询用户
```
```text
>>> query_users(20, 0, min_followers_count=100, include_profile=True)
```

### 函数返回的常见模式
好的函数设计一定是**简单**的，这种简单体现在各个方面，返回多种类型明显违反了简单原则。这种做法不光会给函数本身增加不必要的复杂度，还会提高用户理解和使用函数的成本，尽量只返回一种类型。

适合返回 None 的函数需要满足以下两个特点：
- 函数的名称和参数必须表达**结果可能缺失**的意思；
- 操作类函数不需要任何返回值时，通常会返回 None（默认）；

除了搜索、查询几个场景外，对绝大部分函数而言，返回 None 并不是一个好的做法。用抛出异常来替代返回 None 会更为合理，调用方可以从异常对象里获取错误原因。

对于读代码的人来说，return 是一种有效的思维减负工具。因此，在编写函数时，请不要纠结函数是不是应该只有一个 return，只要尽早返回结果可以提升代码可读性，那就多多返回吧：
```python
def user_get_tweets(user):
    tweets = []
    if user.profile.show_random_tweets:
        tweets.extend(get_random_tweets(user))
    elif user.profile.hide_tweets:
        tweets.append(NULL_TWEET_PLACEHOLDER)
    else:
        token = user.get_token()
        latest_tweets = get_latest_tweets(token)
        tweets.extend([transorm_tweet(item) for item in latest_tweets])
    return tweets
```
```python
def user_get_tweets(user):
    if user.profile.show_random_tweets:
        return get_random_tweets(user)
    if user.profile.hide_tweets:
        return [NULL_TWEET_PLACEHOLDER]
    token = user.get_token()
    latest_tweets = get_latest_tweets(token)
    return [transorm_tweet(item) for item in latest_tweets]
```

### 常用函数模块：functools
functools 模块提供的**高阶函数**（High-order Function）partial 的调用方式为：partial(func, \*args, \*\*kwargs)：
- func 是完成具体功能的原函数；
- \*args/\*\*kwargs 是可选位置与关键字参数，必须是原函数 func 所接收的合法参数；

首先有一个接收许多参数的函数 a，然后额外定义一个接收更少参数的函数 b，通过在 b 内部补充一些预设参数，最后**返回调用 a 函数的结果**：
```python
def multiply(x, y):
    return x * y

def double(value):
    return multiply(2, value)
```
```python
from functools import partial

double = partial(multiply, 2)
```

在缓存方面，functools 模块为我们提供了一个开箱即用的工具：lru_cache()，它可以传入一个可选的 maxsize 参数，该参数代表当前函数最多可以保存多少个缓存结果。如果你把 maxsize 设置为 None，函数就会保存每一个执行结果，**不再剔除任何旧缓存**，这时如果被缓存的内容太多，就会有占用过多内存的风险。

### 编程建议
在函数式编程（Functional Programming）领域，**纯函数**（Pure Function）是一种无状态的函数。相比有状态函数，无状态函数的逻辑通常更容易理解；在并发编程时，无状态函数也有着无须处理状态相关问题的天然优势。

> That said, if you want to write routines longer than about 200 lines, be careful.
\-\- Code Complete

假如你的函数超过 65 行，很大概率代表函数已经过于复杂，承担了太多职责，请考虑将它拆分为多个小而简单的子函数（类）吧；**圈复杂度**（Cyclomatic Complexity）是一个正整数，代表程序内线性独立路径的数量，如果某个函数的圈复杂度超过 10，就代表它已经太复杂了，代码编写者应该想办法简化。我们一般不会在每次写完代码后，都手动执行一次 radon 命令，而会将这种检查配置到开发或部署流程中自动执行。

通用领域的抽象，是指在面对复杂事物（或概念）时，主动过滤掉不需要的细节，只关注与当前目的有关的信息的过程。在计算机科学领域，**分层**思想就是其中最重要的概念之一，低级的抽象层里包含较多的实现细节，随着层级变高，细节越来越少，越接近我们想要解决的实际问题：
![](https://raw.githubusercontent.com/necusjz/p/master/Python/craftsman/1.png)

## 装饰器

### 装饰器基础

### 使用 functools.warps() 修饰包装函数

### 实现可选参数装饰器

### 用类来实现装饰器

#### 函数替换

#### 实例替换

### 使用 wrapt 模块助力装饰器编写

### 编程建议

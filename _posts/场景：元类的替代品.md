---
title: 场景：元类的替代品
abbrlink: 3290605089
date: 2022-03-20 21:12:14
tags: Python
---
> Metaclasses are deeper magic than 99% of users should ever worry about. If you wonder whether you need them, you don’t (the people who actually need them know with certainty that they need them, and don’t need an explanation about why).
-- _Tim Peters_

元类是 Python 中的一种特殊对象，它**控制着类的创建行为**，就像普通类控制着实例的创建行为一样。type 是 Python 中最基本的元类，直接调用 type() 就可以创建一个类：
```text
>>> Foo = type('Foo', (), {'bar': 3})
>>> Foo
<class '__main__.Foo'>
```

在调用 type() 创建类时，需要提供三个参数，它们的含义如下：
- name: str，需要创建的类名；
- bases: Tuple\[Type\]，包含其他类的元组，代表类的所有基类；
- attrs: Dict\[str, Any\]，包含所有类成员（属性、方法）的字典；

元类的功能相当强大，它不光可以修改类，还能修改类的实例。同时它也相当复杂，通常类说，除非要开发一些框架类工具，否则你在日常工作中根本不需要用到元类。
<!--more-->
## 类装饰器
虽然类装饰器并不能覆盖元类的所有功能，但在许多场景下，类装饰器可能比元类更适合，因为它**不光写起来容易，理解起来也更简单**：
```python
_validators = {}

class ValidatorMeta(type):
    def __new__(mcs, name, bases, attrs):
        ret = super().__new__(mcs, name, bases, attrs)
        _validators[attrs['name']] = ret
        return ret

class StringValidator(metaclass=ValidatorMeta):
    name = 'string'

class IntegerValidator(metaclass=ValidatorMeta):
    name = 'int'
```
```python
_validators = {}

def register(cls):
    _validators[cls.name] = cls
    return cls

@register
class StringValidator:
    name = 'string'

@register
class IntegerValidator:
    name = 'int'
```

## \_\_init_subclass\_\_ 钩子方法

## 描述符

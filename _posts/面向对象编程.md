---
title: 面向对象编程
abbrlink: 4207367335
date: 2022-03-20 16:39:34
tags: Python
---
## 面向对象编程
几乎所有现代编程语言都支持面向对象功能，但由于设计理念不同，不同编程语言所支持的面向对象有许多差异。**在 Python 里，万物皆对象**，最基础的浮点数也是一个对象。

### 类常用知识
通过类，我们可以把头脑中的抽象概念进行建模，进而实现复杂的功能。**封装**（Encapsulation）是面向对象编程里的一个重要概念，为了更好地体现类的封装性，许多编程语言支持将属性设置为公开或私有，只是方式略有不同。

当你使用 \_\_{var} 的方式定义一个私有属性时，Python 解释器只是重新给了它一个包含当前类名的别名 **\_{class}\_\_{var}**，因此你仍然可以在外部用这个别名来访问和修改它。

> 设计哲学：期望程序员做正确的事，而不是在语言上增加太多条条框框。

在某些特殊场景下，合理利用 \_\_dict\_\_ 可以帮你完成常规做法难以做到的一些事情：
- 实例的 \_\_dict\_\_ 里，保存着当前实例的所有数据；
- 类的 \_\_dict\_\_ 里，保存着类的文档、方法等所有数据；

<!--more-->
### 内置类方法装饰器
在创建类时，你除了可以定义普通方法外，还可以通过装饰器定义许多特殊对象，这些对象在各自的适宜场景下可以发挥重要作用。

#### 类方法
当你用 def 在类里定义一个函数时，这个函数通常称作方法，调用方法需要先创建一个类实例。虽然普通方法无法通过类来调用，但你可以用 **@classmethod** 装饰器定义一种特殊的方法：类方法，它属于类但是无须实例化也可调用：
```python
class Duck:
    def __init__(self, color):
        self.color = color

    def quack(self):
        print(f"Hi, I'm a {self.color} duck!")

    @classmethod
    def create_random(cls):
        color = random.choice(['yellow', 'white', 'gray'])
        return cls(color=color)
```

类方法最常见的使用场景，就是像上面一样**定义工厂方法来生成新实例**。类方法的主角是类型本身，当你发现某个行为不属于实例，而是属于整个类型时，可以考虑使用类方法。

#### 静态方法
如果你发现某个方法不需要使用当前实例里的任何内容，那就可以使用 **@staticmethod** 来定义一个静态方法：
```python
class Cat:
    def __init__(self, name):
        self.name = name

    def say(self):
        sound = self.get_sound()
        print(f'{self.name}: {sound}...')

    @staticmethod
    def get_sound():
        repeats = random.randrange(1, 10)
        return ' '.join(['Meow'] * repeats)
```

和普通方法相比，静态方法不需要访问实例的任何状态，是一种状态无关的方法，因此静态方法其实可以改写成脱离于类的外部普通函数：
- 如果静态方法特别通用，与类关系不大，那么把它改成普通函数可能会更好；
- 如果静态方法与类关系密切，那么用静态方法更好；
- 相比函数，静态方法有一些先天优势，比如能被子类继承和重写等；

#### 属性装饰器
在一个类里，属性和方法有着不同的职责：**属性代表状态，方法代表行为**：
- 属性可以通过 inst.attr 的方式直接访问；
- 方法需要通过 inst.method() 来调用；

**@property** 是个非常有用的装饰器，它让我们可以基于方法定义类属性，精确地控制属性的读取、赋值和删除行为，灵活地实现动态属性等功能：
```python
class FilePath:
    def __init__(self, path):
        self.path = path

    @property
    def basename(self):
        return self.path.rsplit(os.sep, 1)[-1]

    @basename.setter
    def basename(self, name):
        new_path = self.path.rsplit(os.sep, 1)[:-1] + [name]
        self.path = os.sep.join(new_path)

    @basename.deleter
    def basename(self):
        raise RuntimeError('Can not delete basename!')
```

人们在读取属性时，总是期望能迅速拿到结果，调用方法则不一样——快点儿慢点儿都无所谓。让自己设计的接口符合他人的使用预期，也是写代码时很重要的一环。

### 鸭子类型及其局限性
> If it walks like a duck and it quacks like a duck, then it must be a duck.
\-\- _Wikipedia_

鸭子类型（Duck typing）不是什么真正的类型系统，而是一种特殊的**编程风格**。如果想操作某个对象，你不会去判断它是否属于某种类型，而会直接判断它是不是有你需要的方法（或属性）。这大大提高了代码的灵活性，但也有其局限性：
- **缺乏标准**：虽然我们不需要做严格的类型校验，但是仍然需要频繁判断对象是否支持某个行为，而这方面并没有统一的标准；
- **过于隐式**：对象的真实类型变得不再重要，取而代之的是对象所提供的接口（或协议）变得非常重要，但它们都是隐式的，零碎地分布在代码的各个角落；

### 抽象类
鸭子类型只关心行为，不关心类型，所以 isinstance() 函数天生和鸭子类型的理念相悖。但是有了抽象类以后，我们便可以使用 isinstance(obj, type) 来进行鸭子类型编程风格的类型校验了。只要待匹配类型 type 是抽象类，类型检查就符合鸭子类型编程风格——**只校验行为，不校验类型**：
```python
from abc import ABC, abstractmethod

class Validator(ABC):
    @classmethod
    def __subclasshook__(cls, C):
        # 所有实现了 validate 方法的类都是我的子类
        if any("validate" in B.__dict__ for B in C.__mro__):
            return True
        return NotImplemented

    @abstractmethod
    def validate(self, value):
        raise NotImplementedError
```

\_\_subclasshook\_\_ 类方法是抽象类的一个特殊方法，当你使用 isinstance 检查对象是否属于某个抽象类时，如果后者定义了这个方法，那么该方法就会被触发：
- 实例所属类型会作为参数传入该方法；
- 如果方法返回了布尔值，该值表示实例类型是否属于抽象类的子类；
- 如果方法返回 NotImplemented，本次调用会被忽略，继续进行正常的子类判断逻辑；

通过 \_\_subclasshook\_\_ 钩子和 .register() 方法，实现了一种比继承更灵活、更松散的子类化机制——**结构化子类**，并以此改变了 isinstance() 的行为。

利用 abc 模块的 @abstractmethod 装饰器，你可以把某个方法标记为抽象方法，假如抽象类的子类在继承时，没有重写所有抽象方法，那么它就无法被正常实例化，这个机制可以帮我们更好地控制子类的继承行为，强制要求其重写某些方法；collectioins.abc 模块里的许多抽象类（如 Set、Mapping 等）像普通基类一样实现了一些公用方法，降低了子类的实现成本。

### 多重继承与 MRO
许多编程语言在处理继承关系时，只允许子类继承一个父类，而 Python 里的一个类可以同时继承多个父类。在解决多重继承的方法优先级问题时，Python 使用了一种名为 MRO（Method Resolution Order）的算法，该算法会遍历类的所有基类，并将它们按优先级从高到底排好序。

super() 使用的不是当前类的父类，而是它在 MRO 链条里的上一个类，因此你在方法中调用 super() 时，其实无法确定它会定位到哪一个类。在大多数情况下，你需要的并不是多重继承，而也许只是一个更准确的抽象模型，在该模型下，最普通的继承关系就能完美解决问题。

### 编程建议
Mixin 是一种把额外功能混入某个类的技术，在 Python 中，我们可以用多重继承来实现 Mixin 模式：
```python
class InfoDumperMixin:
    def dump_info(self):
        d = self.__dict__
        print("Number of members: {}".format(len(d)))
        print("Details:")
        for key, value in d.items():
            print(f'  - {key}: {value}')

class Person(InfoDumperMixin):
    def __init__(self, name, age):
        self.name = name
        self.age = age
```

不过，虽然 Mixin 是一种行之有效的编程模式，但不假思索地使用它仍然可能会带来麻烦，你需要精心设计 Mixin 类的职责，让它们和普通类有所区分，这样才能让 Mixin 模式发挥最大的潜力。

继承是一种类与类之间紧密的耦合关系，让子类继承父类，虽然看上去毫无成本地获取了父类的全部能力，但同时也意味着，从此以后父类的所有改动都可能影响子类：
- 我要让 B 类继承 A 类，但 B 和 A 真的代表同一种东西吗？如果它俩不是同类，为什么要继承？
- 即使 B 和 A 是同类，但它们真的需要继承来表明类型关系吗？要知道，Python 是鸭子类型的，你不需要继承也能实现多态；
- 如果继承只是为了让 B 类复用 A 类的几个方法，那么用组合来替代继承会不会更好？

**针对事物的行为建模，而不是对事物本身建模**。同样是复用代码，组合产生的耦合关系比继承松散得多——多用组合，少用继承。但这并不代表我们应该完全弃用继承，继承所提供的强大复用能力，仍然是组合所无法替代的，许多设计模式（比如模版方法模式）都是依托继承来实现的。

在组织类方法时，我们应该关注使用者的诉求，把他们最想知道的内容放在前面，把他们不那么关心的内容放在后面。下面是一些关于组织方法顺序的建议：
- 作为惯例，\_\_init\_\_ 实例化方法应该总是放在类的最前面，\_\_new\_\_ 方法同理；
- 公有方法应该放在类的前面，因为它们是其他模块调用类的入口，是类的门面，也是所有人最关心的内容；
- 以 \_ 开头的私有方法，大部分是类自身的实现细节，应该放在靠后的位置；
- 以 \_\_ 开头的魔法方法比较特殊，通常会按照方法的重要程度来决定它们的位置；
- 当你从上往下阅读类时，所有方法的抽象级别应该是不断降低的；

在写代码时，如果你在原有的面向对象代码上，撒上一点儿函数作为调味品，就会发生奇妙的化学反应。下面是最常见的单例模式实现，当 \_\_new\_\_ 方法被重写后，类的每次实例化返回的不再是新实例，而是同一个已经初始化的旧实例 cls._instance：
```python
class AppConfig:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            inst = super().__new__(cls)
            # TODO: 从外部配置文件读取配置
            cls._instance = inst
        return cls._instance

    def get_database(self):
        # TODO: 读取数据库配置

    def reload(self):
        # TODO: 重新读取配置文件，刷新配置
```

**预绑定方法模式**（Prebound Method Pattern）是一种将对象方法绑定为函数的模式，在 Python 里，实现单例压根儿不用这么麻烦，我们有一个随手可得的单例对象——模块：
```python
class AppConfig:
    def __init__(self):
        # TODO: 从外部配置文件读取配置

    def get_database(self):
        # TODO: 读取数据库配置

    def reload(self):
        # TODO: 重新读取配置文件，刷新配置

_config = AppConfig()
get_database_conf = _config.get_database
reload_config = _config.reload
```

## 面向对象设计原则
_Design Patterns: Elements of Reusable Object-Oriented Software_ 中的大部分设计模式是作者用静态编程语言，在一个有着诸多限制的面向对象环境里创造出来的。而 Python 是一门动态到骨子里的编程语言，它有着一等函数对象、鸭子类型、可自定义的数据模型等各种灵活特性。因此，我们极少会用 Python 来一比一还原经典设计模式，而几乎总是会为每种设计模式找到更适合 Python 的表现形式。

在面向对象领域，除了 23 种经典的设计模式外，还有许多经典的设计原则。同具体的设计模式相比，原则通常更抽象、适用性更广，更适合融入 Python 编程中。

### SRP：单一职责原则
> A class or module should have a single responsibility.

### OCP：开放关闭原则
> Software entities (modules, classes, functions, etc.) should be open for extension, but closed for modification.

### LSP：里式替换原则
> If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program.

### ISP：接口隔离原则
> Clients should not be forced to depend upon interfaces that they do not use.

### DIP：依赖倒置原则
> High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.

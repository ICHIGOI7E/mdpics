---
title: 深入浅出动态规划
abbrlink: 507084228
date: 2022-07-27 00:14:02
tags: CodingInterview
---
## 算法解释
这里我们引用一下维基百科的描述：“**动态规划**在查找有很多**重叠子问题**的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间。动态规划只能应用于有**最优子结构**的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。”
通俗一点来讲，动态规划和其它遍历算法（如深／广度优先搜索）都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划**保存子问题的解，避免重复计算**。解决动态规划问题的关键是找到**状态转移方程**，这样我们可以通过计算和储存子问题的解来求解最终问题。
同时，我们也可以对动态规划进行**空间压缩**，起到节省空间消耗的效果。在一些情况下，动态规划可以看成是带有**状态记录**（Memoization）的优先搜索：
- 状态记录的意思为，如果一个子问题在优先搜索时已经计算过一次，我们可以把它的结果储存下来，之后遍历到该子问题的时候可以直接返回储存的结果。动态规划是自下而上的，即先解决子问题，再解决父问题；
- 而用带有状态记录的优先搜索是自上而下的，即从父问题搜索到子问题，若重复搜索到同一个子问题则进行状态记录，防止重复计算；

如果题目需求的是最终状态，那么使用动态搜索比较方便；如果题目需要输出所有的路径，那么使用带有状态记录的优先搜索会比较方便。
<!--more-->
## 基本动态规划：一维
[70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)
这是十分经典的斐波那契数列题。

[198. House Robber](https://leetcode.com/problems/house-robber/)
我们考虑 dp[i]，此时可以抢劫的最大数量有两种可能，一种是我们选择不抢劫这个房子，此时累计的金额即为dp[i-1]；另一种是我们选择抢劫这个房子，那么此前累计的最大金额只能是 dp[i-2]，因为我们不能够抢劫第 i-1 个房子，否则会触发警报机关。

[413. Arithmetic Slices](https://leetcode.com/problems/arithmetic-slices/)
由于我们对于 dp 数组的定义通常为以 i 结尾的，满足某些条件的子数组数量，而等差子数组可以在任意一个位置终结，因此此题在最后需要对 dp 数组求和。

## 基本动态规划：二维
[64. Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/)
因为每次只能向下或者向右移动，我们可以很容易得到状态转移方程 dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]，其中 grid 表示原数组。
如果不是很熟悉空间压缩技巧，优先尝试写出非空间压缩的解法，如果时间充裕且力所能及再进行空间压缩。

[542. 01 Matrix](https://leetcode.com/problems/01-matrix/)
我们从左上到右下进行一次动态搜索，再从右下到左上进行一次动态搜索。两次动态搜索即可完成四个方向上的查找。

[221. Maximal Square](https://leetcode.com/problems/maximal-square/)
对于在矩阵内搜索正方形或长方形的题型，一种常见的做法是定义一个二维 dp 数组，其中 dp[i][j] 表示满足题目条件的、以 (i, j) 为右下角的正方形或者长方形的属性。

## 分割类型题
[279. Perfect Squares](https://leetcode.com/problems/perfect-squares/)
对于分割类型题，动态规划的状态转移方程通常并不依赖相邻的位置，而是依赖于满足分割条件的位置。

[91. Decode Ways](https://leetcode.com/problems/decode-ways/)
这是一道很经典的动态规划题，难度不大但是十分考验耐心。

[139. Word Break](https://leetcode.com/problems/word-break/)
类似于完全平方数分割问题，这道题的分割条件由集合内的字符串决定，因此在考虑每个分割位置时，需要遍历字符串集合，以确定当前位置是否可以成功分割。

## 子序列问题
[300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)
按照 LeetCode 的习惯，子序列（Subsequence）不必连续，子数组（Subarray）或子字符串（Substring）必须连续。
本题可以使用二分查找将时间复杂度降低为 O(nlogn)。我们定义一个 dp 数组，其中 dp[k] 存储长度为 k+1 的最长递增子序列的最后一个数字，注意 dp 数组最终的形式并不一定是合法的排列形式。

[1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)
对于子序列问题，第二种动态规划方法是，定义一个 dp 数组，其中 dp[i] 表示到位置 i 为止的子序列的性质，并不必须以 i 结尾。这样 dp 数组的最后一位结果即为题目所求，不需要再对每个位置进行统计。

## 背包问题
**背包问题**是一种组合优化的 NP 完全问题：有 N 个物品和容量为 W 的背包，每个物品都有自己的体积 w 和价值 v，求拿哪些物品可以使得背包所装下物品的总价值最大。如果限定每种物品只能选择 0 个或 1 个，则问题称为 **0-1 背包问题**；如果不限定每种物品的数量，则问题称为**无界背包问题或完全背包问题**。
我们可以用动态规划来解决背包问题。以 0-1 背包问题为例。我们可以定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。在我们遍历到第 i 件物品时，在当前背包总容量为 j 的情况下，如果我们不将物品 i 放入背包，那么 dp[i][j] = dp[i-1][j]，即前 i 个物品的最大价值等于只取前 i-1 个物品时的最大价值；如果我们将物品 i 放入背包，假设第 i 件物品体积为 w，价值为 v，那么我们得到 dp[i][j] = dp[i-1][j-w] + v。我们只需在遍历过程中对这两种情况取最大值即可，总时间复杂度和空间复杂度都为 O(NW)：
```python
def knapsack(weights, values, N, W):
    dp = [[0] * (W + 1) for _ in range(N + 1)]

    for i in range(1, N + 1):
        w, v = weights[i-1], values[i-1]
        for j in range(1, W + 1):
            if j >= w:
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-w] + v)
            else:
                dp[i][j] = dp[i-1][j]
    
    return dp[N][W]
```

## 字符串编辑

## 股票交易

## 练习
[213. House Robber II](https://leetcode.com/problems/house-robber-ii/)
强盗抢劫题目的 follow-up，如何处理环形数组呢？

[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)
经典的一维动态规划题目，试着把一维空间优化为常量吧。

[343. Integer Break](https://leetcode.com/problems/integer-break/)
分割类型题，先尝试用动态规划求解，再思考是否有更简单的解法。

[583. Delete Operation for Two Strings](https://leetcode.com/problems/delete-operation-for-two-strings/)
最长公共子序列的变种题。

[646. Maximum Length of Pair Chain](https://leetcode.com/problems/maximum-length-of-pair-chain/)
最长递增子序列的变种题，同样的，尝试用二分进行加速。

[376. Wiggle Subsequence](https://leetcode.com/problems/wiggle-subsequence/)
最长摆动子序列，通项公式比较特殊，需要仔细思考。

[494. Target Sum](https://leetcode.com/problems/target-sum/)
如果告诉你这道题是 0-1 背包，你是否会有一些思路？

[714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)
建立状态机，股票交易类问题就会迎刃而解。

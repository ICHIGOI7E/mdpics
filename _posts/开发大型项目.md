---
title: 开发大型项目
abbrlink: 2857695660
date: 2022-03-22 00:10:30
tags: Python
---
## 数据模型与描述符
在 Python 中，数据模型（Data Model）是一个非常重要的概念，假如把 Python 语言看作一个框架，数据模型就描述了框架如何工作，创建怎样的对象才能更好地融入 Python 这个框架。所有与数据模型有关的方法，基本都是以双下划线 \_\_ 开头和结尾，它们通常被称为**魔法方法**（Magic Method）。

### 字符串魔法方法
```python
class Person:
    def __init__(self, name, age, favorite_color):
        self.name = name
        self.age = age
        self.favorite_color = favorite_color

    def __str__(self):
        return self.name

    def __repr__(self):
        # 变量名后的 !r 表示在渲染字符串模版时，程序会优先使用 repr() 而非 str() 的结果
        return '{cls_name}(name={name!r}, age={age!r}, favorite_color={color!r})'.format(
            cls_name=self.__class__.__name__,
            name=self.name,
            age=self.age,
            color=self.favorite_color,
        )

    def __format__(self, format_spec):
        if format_spec == 'verbose':
            return f'{self.name}({self.age})[{self.favorite_color}]'
        elif format_spec == 'simple':
            return f'{self.name}({self.age})'
        return self.name
```
<!--more-->
#### \_\_str\_\_
使用 \_\_str\_\_ 方法，可以定义对象的字符串值。这种场景下的字符串注重**可读性**，格式应当对用户友好：
```text
>>> p = Person('ethan', 18, 'black')
>>> print(p)
ethan
```

#### \_\_repr\_\_
使用 \_\_repr\_\_ 方法，可以定义对象对调试友好的详细字符串值。这种场景下的字符串注重内容的**完整性**：
```text
>>> p = Person('ethan', 18, 'black')
>>> p
Person(name='ethan', age=18, favorite_color='black')
```

#### \_\_format\_\_
使用 \_\_format\_\_ 方法，可以在对象用于字符串模版渲染时，提供多种字符串值：
```text
>>> p = Person('ethan', 18, 'black')
>>> print(f'{p:verbose}')
ethan(18)[black]
>>> print(f'{p:simple}')
ethan(18)
```

### 比较运算符重载
与比较运算符相关的魔法方法共 6 个，如果使用 **@total_ordering** 装饰一个类，那么在重载类的比较运算符时，你只要先实现 \_\_eq\_\_ 方法，然后在 \_\_lt\_\_、\_\_le\_\_、\_\_gt\_\_、\_\_ge\_\_ 四个方法里随意挑一个实现即可，@total_ordering 会帮你自动补全剩下的所有方法：
```python
from functools import total_ordering

@total_ordering
class Square:
    def __init__(self, length):
        self.length = length

    def area(self):
        return self.length ** 2

    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return self.length == other.length
        return False

    def __lt__(self, other):
        if isinstance(other, self.__class__):
            return self.length < other.length
        return NotImplemented
```

### 描述符
描述符（Descriptor）是 Python 对象模型里的一种特殊协议，任何一个实现了 \_\_get\_\_、\_\_set\_\_ 或 \_\_delete\_\_ 的类，都可以称为**描述符类**，它的实例则叫作描述符对象。

按照实现方式的不同，描述符可以分为两大类：
- **非数据描述符**：只实现了 \_\_get\_\_ 方法的描述符，比如实例方法、类方法、静态方法，你可以轻易覆盖它们的行为；
- **数据描述符**：实现了 \_\_set\_\_ 或 \_\_delete\_\_ 其中任何一个方法的描述符，比如属性装饰器，你无法直接通过重写修改它的状态；

#### 无描述符时，实现属性校验功能
使用属性装饰器最大的缺点是——**很难复用**：
```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    @property
    def age(self):
        return self._age

    @age.setter
    def age(self, value):
        try:
            value = int(value)
        except (TypeError, ValueError):
            raise ValueError('value is not a valid integer!')

        if not (0 <= value <= 150):
            raise ValueError('value must between 0 and 150!')
        self._age = value
```

#### 用描述符实现属性校验功能
为了提供更高的可复用性，这次我们在年龄字段的基础上抽象出一个支持校验功能的整型描述符类型：
```python
class IntegerField:
    def __init__(self, min_value, max_value):
        self.min_value = min_value
        self.max_value = max_value

    def __set_name__(self, owner, name):
        # 将绑定属性名保存在描述符对象中
        self._name = name

    def __get__(self, instance, owner=None):
        if not instance:
            return self
        # 在数据存取时，使用动态的 self._name
        return instance.__dict__[self._name]

    def __set__(self, instance, value):
        value = self._validate_value(value)
        instance.__dict__[self._name] = value

    def _validate_value(self, value):
        try:
            value = int(value)
        except (TypeError, ValueError):
            raise ValueError(f'{self._name} is not a valid integer!')

        if not (self.min_value <= value <= self.max_value):
            raise ValueError(f'{self._name} must between {self.min_value} and {self.max_value}!')
        return value
```

### 编程建议
每当你想要重写 \_\_hash\_\_ 方法时，一定要保证方法产生的哈希值是稳定的，不会随着对象状态而改变：
- 对象不可变，不允许任何修改，比如定义 dataclass 时指定的 frozen=True；
- 至少保证，被卷入哈希值计算的条件不会改变；

虽然数据模型能帮我们写出更 Pythonic 的代码，但切勿过度推崇：
```python
class Events:
    def __init__(self, events):
        self.events = events

    def is_empty(self):
        return not bool(self.events)

    def list_events_by_range(self, start, end):
        return self.events[start:end]
```
```python
class Events:
    def __init__(self, events):
        self.events = events
    
    def __len__(self):
        return len(self.events)

    def __getitem__(self, index):
        return self.events[index]
```

**\_\_del\_\_ 方法不是在执行 del 语句时被触发**8，而是在对象被作为垃圾回收时被触发。换句话说，del 让对象的引用计数减 1，但只有当引用计数降为 0 时，它才会马上被 Python 解释器回收，不要使用 \_\_del\_\_ 来做任何自动化的资源回收工作。

## 开发大型项目
Python 的自由感体现在，它既可以用来写一些快糙猛的小脚本，同时也能用它来做一些真正的大项目，解决一些更为复杂的问题。在经历了多年发展后，如今的 Python 有着成熟的打包机制、强大的工具链以及繁荣的第三方生态，无数企业乐于用 Python 来开发重要项目。

### 常用工具介绍
在多人参与的大型项目里，最基本的一件事就是让所有人的代码风格保持一致，整洁得就像是出自同一人之手。

#### flake8
Python 有一份官方代码风格指南：PEP 8，但在开发项目时，光有一套纸面上的规范是不够的。纸面规范只适合阅读，无法用来快速检索真实代码是否符合规范，只有通过 Linter 才能最大地发挥 PEP 8 的作用。

> Linter 指一类特殊的代码静态分析工具，专门用来找出代码里的格式问题、语法问题等，帮助提升代码质量。

flake8 的主要检查能力是由它所集成的其他工具所提供的：
- pycodestyle：PEP 8 检查工具；
- pyflakes：更专注于检查代码的正确性，比如语法错误、变量名未定义等；
- mccabe：扫描代码的圈复杂度；

此外，flake8 还通过插件机制提供了强大的定制能力，可谓 Python 代码检查领域的一把瑞士军刀，非常值得在项目中使用。

#### isort
PEP 8 认为，一个源码文件的所有 import 语句，都应该依照以下规则分为三组：
1. 导入 Python 标准库包的 import 语句；
2. 导入相关联的第三方包的 import 语句；
3. 与当前应用（或当前库）相关的 import 语句；

有了 isort 以后，你在调整 import 语句时可以变得随心所欲，只需负责一些简单的编辑工作，isort 会帮你搞定剩下的所有事情。

#### black
虽然 PEP 8 规范为许多代码风格问题提供了标准答案，但这份答案其实非常宏观，在许多细节要求上并不严格。在许多场景中，同一段代码在符合 PEP 8 规范的前提下，可以写成好几种风格。作为一个代码格式化工具，black 最大的特点就在于它的不可配置性：
> The uncompromising Python code formatter.
\-\- _GitHub_

black 能让我们不用在各种编码风格间纠结，能有效解决许多问题，整体来看，在大型项目中引入 black，利远大于弊。

#### pre-commit
只是安装好工具，再偶尔手动执行那么一两次是远远不够的，要最大地发挥工具的能力，你必须让它们融入所有人的开发流程里。Git 有个特殊的钩子功能，它允许你给每个仓库配置一些钩子程序（Hook），之后每当你进行特定的 Git 操作时，这些钩子程序就会执行。

pre-commit 是一个专门用于预提交阶段的工具，要使用它，你需要先创建一个配置文件 **.pre-commit-config.yaml**，由于它与项目源码存放在一起，都在代码仓库中，因此项目的所有开发者天然共享 pre-commit 的插件配置，每个人不用单独维护各自的配置。

#### mypy
在现实世界里，我们写的程序里的许多 bug 都和类型系统息息相关。mypy 是最为流行的静态类型检查工具，在大型项目中，类型注解与 mypy 的组合能大大提高项目代码的可读性与正确性。mypy 让动态类型的 Pyhon 拥有了部分静态类型语言才有的能力，值得在大型项目中推广使用。

### 单元测试简介
根据关注点的不同，自动化测试可以分为不同的

#### unittest

#### pytest

### 编程建议
